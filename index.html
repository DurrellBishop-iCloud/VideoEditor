<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Three Line Edit</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: none;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #1a1a1a;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
    }

    #app {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
    }

    /* File input overlay */
    #load-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #1a1a1a;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      color: #fff;
    }

    #load-overlay.hidden {
      display: none;
    }

    #load-overlay p {
      color: #888;
      font-size: 16px;
    }

    /* Preview area - top half */
    #preview-area {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #000;
      position: relative;
      overflow: hidden;
    }

    #video {
      display: none;
    }

    #preview-canvas {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    #play-indicator {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 60px;
      height: 60px;
      background: rgba(0,0,0,0.6);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
    }

    #play-indicator.show {
      opacity: 1;
    }

    #play-indicator::after {
      content: '';
      width: 0;
      height: 0;
      border-left: 20px solid white;
      border-top: 12px solid transparent;
      border-bottom: 12px solid transparent;
      margin-left: 5px;
    }

    #play-indicator.playing::after {
      border: none;
      width: 20px;
      height: 24px;
      background: linear-gradient(to right, white 35%, transparent 35%, transparent 65%, white 65%);
      margin-left: 0;
    }

    #time-display {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 6px 14px;
      border-radius: 6px;
      font-size: 14px;
      font-variant-numeric: tabular-nums;
    }

    /* Edit buttons panel */
    #edit-panel {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 10;
    }

    .edit-btn {
      width: 50px;
      height: 50px;
      border: none;
      border-radius: 8px;
      background: rgba(0,0,0,0.6);
      color: white;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 2px;
    }

    .edit-btn.active {
      background: #3b82f6;
    }

    .edit-btn .icon {
      font-size: 18px;
    }

    #marker-display {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      color: #22c55e;
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 12px;
      font-variant-numeric: tabular-nums;
    }

    /* Edit list stripe */
    #edit-list-stripe {
      height: 60px;
      background: #1a1a2e;
      border-bottom: 2px solid #3b82f6;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      z-index: 5;
      display: none;
    }

    #edit-list-stripe.has-clips {
      display: block;
    }

    #edit-list-stripe .stripe-label {
      position: absolute;
      top: 4px;
      left: 8px;
      background: #3b82f6;
      color: white;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
      z-index: 6;
    }

    #edit-list-stripe canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    /* Adjust stripes container when edit list is visible */
    #stripes-area.has-edit-list #stripes-container {
      top: 62px;
    }

    /* Stripes area - bottom half */
    #stripes-area {
      flex: 1;
      background: #0a0a0a;
      position: relative;
      overflow: hidden;
    }

    #stripes-container {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      display: flex;
      flex-direction: column;
      transition: transform 0.1s ease-out;
    }

    /* Center line indicator */
    #center-line {
      position: absolute;
      top: 0;
      left: 50%;
      width: 2px;
      height: 100%;
      background: #ef4444;
      z-index: 10;
      pointer-events: none;
    }

    #center-line::before,
    #center-line::after {
      content: '';
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
    }

    #center-line::before {
      top: 0;
      border-top: 10px solid #ef4444;
    }

    #center-line::after {
      bottom: 0;
      border-bottom: 10px solid #ef4444;
    }

    .stripe {
      height: 80px;
      position: relative;
      overflow: hidden;
      border-bottom: 1px solid #333;
      flex-shrink: 0;
    }

    .stripe-label {
      position: absolute;
      top: 4px;
      left: 8px;
      background: rgba(0,0,0,0.7);
      color: #888;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
      z-index: 5;
      pointer-events: none;
    }

    .stripe canvas {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
    }

    /* Version number */
    #version {
      position: fixed;
      top: 10px;
      left: 10px;
      color: #666;
      font-size: 11px;
      z-index: 1001;
      pointer-events: none;
    }

    /* Control Panel Toggle Button */
    #control-toggle {
      position: fixed;
      top: 10px;
      left: 50px;
      width: 36px;
      height: 36px;
      background: rgba(0, 0, 0, 0.6);
      border: none;
      border-radius: 50%;
      z-index: 1002;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
    }

    /* Control Panel */
    #control-panel {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: rgba(20, 20, 20, 0.98);
      z-index: 1001;
      transform: translateY(-100%);
      transition: transform 0.3s ease-out;
      padding: 60px 20px 20px 20px;
      border-bottom: 1px solid #333;
    }

    #control-panel.visible {
      transform: translateY(0);
    }

    .control-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 14px 0;
      border-bottom: 1px solid #333;
      color: #fff;
      font-size: 16px;
    }

    .control-item:last-child {
      border-bottom: none;
    }

    .control-item label {
      cursor: pointer;
    }

    .control-item input[type="file"] {
      display: none;
    }

    .control-btn {
      background: #3b82f6;
      border: none;
      color: white;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 14px;
      cursor: pointer;
    }

    .control-btn.secondary {
      background: #4b5563;
    }

    .control-version {
      color: #666;
      font-size: 12px;
      text-align: center;
      padding-top: 15px;
    }

    /* Debug Console */
    #debug-console {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 40%;
      background: rgba(0, 0, 0, 0.95);
      border-top: 2px solid #22c55e;
      z-index: 1000;
      display: none;
      flex-direction: column;
      font-family: 'SF Mono', Monaco, 'Courier New', monospace;
    }

    #debug-console.visible {
      display: flex;
    }

    #debug-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: #1a1a1a;
      border-bottom: 1px solid #333;
    }

    #debug-header span {
      color: #22c55e;
      font-size: 12px;
      font-weight: bold;
    }

    #debug-buttons {
      display: flex;
      gap: 8px;
    }

    #debug-buttons button {
      padding: 6px 12px;
      font-size: 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 600;
    }

    #copy-btn {
      background: #3b82f6;
      color: white;
    }

    #clear-btn {
      background: #ef4444;
      color: white;
    }

    #debug-log {
      flex: 1;
      overflow-y: auto;
      padding: 8px 12px;
      font-size: 11px;
      line-height: 1.4;
      -webkit-overflow-scrolling: touch;
      user-select: text;
      -webkit-user-select: text;
    }

    .log-entry {
      padding: 4px 0;
      border-bottom: 1px solid #222;
      color: #ddd;
      word-wrap: break-word;
    }

    .log-entry.error {
      color: #ef4444;
    }

    .log-entry.warn {
      color: #f59e0b;
    }

    .log-entry.info {
      color: #22c55e;
    }

    .log-time {
      color: #666;
      margin-right: 8px;
    }

    #copy-toast {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #22c55e;
      color: white;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 1001;
    }

    #copy-toast.show {
      opacity: 1;
    }
  </style>
</head>
<body>
  <!-- Version -->
  <div id="version">v2.0</div>

  <!-- Control Panel Toggle -->
  <button id="control-toggle">&#9881;</button>

  <!-- Control Panel -->
  <div id="control-panel">
    <div class="control-item">
      <span>Load Video</span>
      <label class="control-btn">
        Choose File
        <input type="file" id="file-input" accept="video/*">
      </label>
    </div>
    <div class="control-item">
      <span>Debug Console</span>
      <button class="control-btn secondary" id="debug-toggle">Show</button>
    </div>
    <div class="control-version">Three Line Edit v2.0</div>
  </div>

  <!-- Debug Console -->
  <div id="debug-console">
    <div id="debug-header">
      <span>DEBUG CONSOLE</span>
      <div id="debug-buttons">
        <button id="copy-btn">Copy All</button>
        <button id="clear-btn">Clear</button>
      </div>
    </div>
    <div id="debug-log"></div>
  </div>
  <div id="copy-toast">Copied to clipboard!</div>

  <div id="app">
    <div id="load-overlay">
      <p>Choose a video file above to begin</p>
    </div>

    <div id="preview-area">
      <video id="video" playsinline preload="auto" muted></video>
      <canvas id="preview-canvas"></canvas>
      <div id="play-indicator"></div>
      <div id="time-display">00:00.000 / 00:00.000</div>
      <div id="marker-display" style="display:none"></div>
      <div id="edit-panel">
        <button class="edit-btn" id="btn-mark-in">
          <span class="icon">[</span>
          <span>IN</span>
        </button>
        <button class="edit-btn" id="btn-mark-out">
          <span class="icon">]</span>
          <span>OUT</span>
        </button>
        <button class="edit-btn" id="btn-keep" style="background:#22c55e;">
          <span class="icon">+</span>
          <span>KEEP</span>
        </button>
        <button class="edit-btn" id="btn-delete" style="background:#ef4444;">
          <span class="icon">−</span>
          <span>DEL</span>
        </button>
        <button class="edit-btn" id="btn-move" style="background:#f59e0b;">
          <span class="icon">→</span>
          <span>MOVE</span>
        </button>
        <button class="edit-btn" id="btn-clear">
          <span class="icon">×</span>
          <span>CLR</span>
        </button>
      </div>
    </div>

    <div id="stripes-area">
      <div id="center-line"></div>
      <div id="edit-list-stripe">
        <span class="stripe-label">Edit List</span>
        <canvas></canvas>
      </div>
      <div id="stripes-container">
        <div class="stripe" id="stripe-0"><span class="stripe-label">Fine</span><canvas></canvas></div>
        <div class="stripe" id="stripe-1"><span class="stripe-label">Medium</span><canvas></canvas></div>
        <div class="stripe" id="stripe-2"><span class="stripe-label">Wide</span><canvas></canvas></div>
        <div class="stripe" id="stripe-3"><span class="stripe-label">Coarse</span><canvas></canvas></div>
        <div class="stripe" id="stripe-4"><span class="stripe-label">Full</span><canvas></canvas></div>
      </div>
    </div>
  </div>

  <script>
    // ===== CONTROL PANEL & DEBUG CONSOLE =====
    const controlPanel = document.getElementById('control-panel');
    const controlToggle = document.getElementById('control-toggle');
    const debugConsole = document.getElementById('debug-console');
    const debugToggle = document.getElementById('debug-toggle');
    const debugLog = document.getElementById('debug-log');
    const copyBtn = document.getElementById('copy-btn');
    const clearBtn = document.getElementById('clear-btn');
    const copyToast = document.getElementById('copy-toast');
    let logEntries = [];

    // Toggle control panel
    controlToggle.addEventListener('click', () => {
      controlPanel.classList.toggle('visible');
    });

    // Toggle debug console
    debugToggle.addEventListener('click', () => {
      const isVisible = debugConsole.classList.toggle('visible');
      debugToggle.textContent = isVisible ? 'Hide' : 'Show';
      controlPanel.classList.remove('visible');
    });

    function getTimestamp() {
      const now = new Date();
      return now.toTimeString().split(' ')[0] + '.' + now.getMilliseconds().toString().padStart(3, '0');
    }

    function addLog(message, type = 'log') {
      const timestamp = getTimestamp();
      const entry = { timestamp, message: String(message), type };
      logEntries.push(entry);

      const div = document.createElement('div');
      div.className = `log-entry ${type}`;
      div.innerHTML = `<span class="log-time">${timestamp}</span>${String(message).replace(/</g, '&lt;').replace(/>/g, '&gt;')}`;
      debugLog.appendChild(div);
      debugLog.scrollTop = debugLog.scrollHeight;
    }

    // Capture console methods
    const originalLog = console.log;
    const originalError = console.error;
    const originalWarn = console.warn;
    const originalInfo = console.info;

    console.log = function(...args) {
      addLog(args.map(a => typeof a === 'object' ? JSON.stringify(a) : a).join(' '), 'log');
      originalLog.apply(console, args);
    };

    console.error = function(...args) {
      addLog(args.map(a => typeof a === 'object' ? JSON.stringify(a) : a).join(' '), 'error');
      originalError.apply(console, args);
    };

    console.warn = function(...args) {
      addLog(args.map(a => typeof a === 'object' ? JSON.stringify(a) : a).join(' '), 'warn');
      originalWarn.apply(console, args);
    };

    console.info = function(...args) {
      addLog(args.map(a => typeof a === 'object' ? JSON.stringify(a) : a).join(' '), 'info');
      originalInfo.apply(console, args);
    };

    // Capture errors
    window.onerror = function(msg, url, lineNo, columnNo, error) {
      addLog(`ERROR: ${msg} at ${url}:${lineNo}:${columnNo}`, 'error');
      return false;
    };

    window.onunhandledrejection = function(event) {
      addLog(`UNHANDLED PROMISE: ${event.reason}`, 'error');
    };

    // Copy button
    copyBtn.addEventListener('click', async () => {
      const text = logEntries.map(e => `[${e.timestamp}] [${e.type.toUpperCase()}] ${e.message}`).join('\n');
      try {
        await navigator.clipboard.writeText(text);
        copyToast.classList.add('show');
        setTimeout(() => copyToast.classList.remove('show'), 1500);
      } catch (err) {
        // Fallback for iOS
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed';
        textarea.style.top = '50%';
        textarea.style.left = '0';
        textarea.style.width = '100%';
        textarea.style.height = '200px';
        textarea.style.zIndex = '9999';
        textarea.style.fontSize = '12px';
        document.body.appendChild(textarea);
        textarea.focus();
        textarea.select();
        addLog('Text area opened - select all and copy manually', 'info');
      }
    });

    // Clear button
    clearBtn.addEventListener('click', () => {
      debugLog.innerHTML = '';
      logEntries = [];
      addLog('Console cleared', 'info');
    });

    console.info('Debug console initialized');
    console.info('User Agent: ' + navigator.userAgent);

    // ===== MAIN APP =====

    // State
    const state = {
      video: null,
      duration: 0,
      currentTime: 0,
      isPlaying: false,
      frames: [], // Cached frame images
      frameInterval: 1/30, // Seconds between cached frames
      videoWidth: 0,
      videoHeight: 0,
      // Edit markers
      markIn: null,
      markOut: null,
      // Edit list - array of {inTime, outTime} clips for the "kept" timeline
      editList: [],
      editListDuration: 0,
      // Deleted ranges - array of {inTime, outTime} to skip in source
      deletedRanges: []
    };

    // Elements
    const video = document.getElementById('video');
    const previewCanvas = document.getElementById('preview-canvas');
    const previewCtx = previewCanvas.getContext('2d');
    const playIndicator = document.getElementById('play-indicator');
    const timeDisplay = document.getElementById('time-display');
    const loadOverlay = document.getElementById('load-overlay');
    const fileInput = document.getElementById('file-input');
    const stripesArea = document.getElementById('stripes-area');

    // Stripe configurations (will be set relative to video length)
    const stripes = [
      { id: 'stripe-0', baseWindow: 0.5, label: 'Fine', frameScale: 1.0 },
      { id: 'stripe-1', baseWindow: 2, label: 'Medium', frameScale: 0.5 },
      { id: 'stripe-2', baseWindow: 8, label: 'Wide', frameScale: 0.3 },
      { id: 'stripe-3', baseWindow: 30, label: 'Coarse', frameScale: 0.2 },
      { id: 'stripe-4', baseWindow: 120, label: 'Full', frameScale: 0.15 }
    ];

    // Initialize stripe data
    stripes.forEach(stripe => {
      stripe.element = document.getElementById(stripe.id);
      stripe.canvas = stripe.element.querySelector('canvas');
      stripe.ctx = stripe.canvas.getContext('2d');
      stripe.window = stripe.baseWindow; // Will be adjusted
    });

    // Format time as MM:SS.mmm
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      const ms = Math.floor((seconds % 1) * 1000);
      return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
    }

    // Update time display
    function updateTimeDisplay() {
      timeDisplay.textContent = `${formatTime(state.currentTime)} / ${formatTime(state.duration)}`;
    }

    // Adjust windows relative to video length
    function adjustWindows() {
      const dur = state.duration;
      // Scale windows based on video duration
      const scale = Math.max(0.5, Math.min(2, dur / 30));

      stripes.forEach(stripe => {
        // Scale the base window, but cap at video duration
        stripe.window = Math.min(dur, stripe.baseWindow * scale);

        // Update label
        const label = stripe.element.querySelector('.stripe-label');
        if (stripe.window >= 60) {
          label.textContent = `${stripe.label} (${(stripe.window/60).toFixed(1)}m)`;
        } else {
          label.textContent = `${stripe.label} (${stripe.window.toFixed(1)}s)`;
        }
      });
    }

    // Extract frames from video
    async function extractFrames() {
      console.info('Starting frame extraction...');
      state.frames = [];
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');

      // Use smaller thumbnails for memory efficiency
      const thumbHeight = 80;
      const thumbWidth = Math.round((state.videoWidth / state.videoHeight) * thumbHeight);
      tempCanvas.width = thumbWidth;
      tempCanvas.height = thumbHeight;

      console.log(`Thumb size: ${thumbWidth}x${thumbHeight}`);

      const totalFrames = Math.ceil(state.duration / state.frameInterval);
      console.log(`Total frames to extract: ${totalFrames} (duration: ${state.duration}s, interval: ${state.frameInterval}s)`);

      return new Promise((resolve, reject) => {
        let frameIndex = 0;
        let seekTimeout = null;
        let lastSeekTime = Date.now();

        const extractNext = () => {
          if (frameIndex >= totalFrames) {
            console.info(`Frame extraction complete! ${state.frames.length} frames extracted`);
            resolve();
            return;
          }

          const time = frameIndex * state.frameInterval;
          console.log(`Seeking to frame ${frameIndex}/${totalFrames} at time ${time.toFixed(3)}s`);
          lastSeekTime = Date.now();

          // Set a timeout to detect if seeking hangs
          if (seekTimeout) clearTimeout(seekTimeout);
          seekTimeout = setTimeout(() => {
            console.error(`SEEK TIMEOUT! Stuck at frame ${frameIndex}, time ${time.toFixed(3)}s`);
            console.error(`Video readyState: ${video.readyState}, networkState: ${video.networkState}`);
            console.error(`Video seeking: ${video.seeking}, paused: ${video.paused}`);
            // Try to continue anyway
            frameIndex++;
            extractNext();
          }, 5000);

          video.currentTime = time;
        };

        video.onseeked = () => {
          if (seekTimeout) clearTimeout(seekTimeout);
          const seekDuration = Date.now() - lastSeekTime;

          try {
            tempCtx.drawImage(video, 0, 0, thumbWidth, thumbHeight);
            state.frames.push({
              time: frameIndex * state.frameInterval,
              imageData: tempCanvas.toDataURL('image/jpeg', 0.7)
            });
            frameIndex++;

            // Show progress
            const progress = Math.round((frameIndex / totalFrames) * 100);
            loadOverlay.querySelector('p').textContent = `Extracting frames: ${progress}%`;

            // Log every 10 frames to avoid spam
            if (frameIndex % 10 === 0 || frameIndex === 1) {
              console.log(`Extracted frame ${frameIndex}/${totalFrames} (${progress}%) - seek took ${seekDuration}ms`);
            }

            // Use setTimeout to prevent blocking
            setTimeout(extractNext, 0);
          } catch (err) {
            console.error(`Error extracting frame ${frameIndex}: ${err.message}`);
            frameIndex++;
            setTimeout(extractNext, 0);
          }
        };

        video.onerror = (e) => {
          console.error(`Video error: ${video.error ? video.error.message : 'unknown'}`);
          console.error(`Error code: ${video.error ? video.error.code : 'N/A'}`);
        };

        console.log('Starting extraction loop...');
        extractNext();
      });
    }

    // Draw preview frame
    function drawPreview() {
      previewCtx.drawImage(video, 0, 0, previewCanvas.width, previewCanvas.height);
    }

    // Find closest cached frame
    function getFrameAtTime(time) {
      if (state.frames.length === 0) return null;

      let closest = state.frames[0];
      let minDiff = Math.abs(time - closest.time);

      for (const frame of state.frames) {
        const diff = Math.abs(time - frame.time);
        if (diff < minDiff) {
          minDiff = diff;
          closest = frame;
        }
        if (frame.time > time) break; // Frames are sorted
      }

      return closest;
    }

    // Draw a stripe
    function drawStripe(stripe) {
      const ctx = stripe.ctx;
      const timeWindow = stripe.window;
      const frameScale = stripe.frameScale || 1.0;

      // Use element dimensions (not canvas dimensions which are 2x for retina)
      const width = stripe.element.clientWidth;
      const height = stripe.element.clientHeight;

      ctx.fillStyle = '#0a0a0a';
      ctx.fillRect(0, 0, width, height);

      // Calculate frame dimensions - scale affects size
      const frameHeight = (height - 4) * frameScale;
      const frameWidth = Math.round((state.videoWidth / state.videoHeight) * frameHeight);
      const frameY = (height - frameHeight) / 2; // Center vertically

      // Time per pixel
      const timePerPixel = timeWindow / width;

      // Center of the stripe = current time
      const centerX = width / 2;

      // How many frames to show (enough to fill the width plus extra)
      const framesNeeded = Math.ceil(width / frameWidth) + 4;

      // Draw frames centered on current time
      for (let i = -Math.ceil(framesNeeded / 2); i <= Math.ceil(framesNeeded / 2); i++) {
        // Calculate time offset for this frame position
        const pixelOffset = i * frameWidth;
        const frameTime = state.currentTime + (pixelOffset * timePerPixel);

        if (frameTime < 0 || frameTime > state.duration) continue;

        const frame = getFrameAtTime(frameTime);
        if (!frame || !frame.image) continue;

        // Position: center of frame aligns with its time position
        const timeDiff = frameTime - state.currentTime;
        const x = centerX + (timeDiff / timePerPixel) - (frameWidth / 2);

        ctx.drawImage(frame.image, x, frameY, frameWidth, frameHeight);

        // Draw subtle border
        ctx.strokeStyle = '#333';
        ctx.strokeRect(x, frameY, frameWidth, frameHeight);
      }
    }

    // Draw all stripes
    function drawAllStripes() {
      stripes.forEach(drawStripe);
    }

    // Seek video to time
    function seekTo(time) {
      state.currentTime = Math.max(0, Math.min(state.duration, time));
      video.currentTime = state.currentTime;
      updateTimeDisplay();
      drawAllStripes();
    }

    // Update preview when video seeks (for scrubbing)
    video.addEventListener('seeked', () => {
      if (!state.isPlaying && state.duration > 0) {
        drawPreview();
      }
    });

    // Monitor video events to catch buffer/reset issues
    video.addEventListener('emptied', () => {
      console.error('VIDEO EVENT: emptied - buffer was cleared!');
    });

    video.addEventListener('stalled', () => {
      console.warn('VIDEO EVENT: stalled - buffering stalled');
    });

    video.addEventListener('waiting', () => {
      console.warn('VIDEO EVENT: waiting - waiting for data');
    });

    video.addEventListener('error', () => {
      console.error(`VIDEO EVENT: error - ${video.error ? video.error.message : 'unknown'}`);
    });

    video.addEventListener('loadstart', () => {
      console.info('VIDEO EVENT: loadstart');
    });

    video.addEventListener('timeupdate', () => {
      // Check for unexpected jumps to start
      if (state.duration > 0 && !state.isPlaying) {
        if (video.currentTime < 0.1 && state.currentTime > 1) {
          console.error(`VIDEO JUMPED TO START! Was at ${state.currentTime.toFixed(2)}s - attempting recovery`);
          // Try to recover by seeking back to where we were
          video.currentTime = state.currentTime;
        }
      }
    });

    // iOS keepalive - prevent Safari from releasing video buffer
    let lastKeepAlive = Date.now();
    setInterval(() => {
      if (state.duration > 0 && !state.isPlaying) {
        const now = Date.now();
        // Every 3 seconds, "touch" the video to keep it alive
        if (now - lastKeepAlive > 3000) {
          lastKeepAlive = now;
          // Small seek to current position keeps buffer active
          const targetTime = state.currentTime;
          if (Math.abs(video.currentTime - targetTime) > 0.5) {
            console.warn(`Keepalive: resyncing video from ${video.currentTime.toFixed(2)} to ${targetTime.toFixed(2)}`);
            video.currentTime = targetTime;
          }
        }
      }
    }, 1000);

    // Store video URL globally so we can reload if needed
    let videoUrl = null;

    // Animation loop
    function animate() {
      if (state.isPlaying) {
        state.currentTime = video.currentTime;
        drawPreview();
        updateTimeDisplay();
        drawAllStripes();
      }
      requestAnimationFrame(animate);
    }

    // Handle video load
    async function loadVideo(file) {
      // Close control panel
      controlPanel.classList.remove('visible');

      console.info(`Loading video: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`);
      console.log(`File type: ${file.type}`);

      // Store URL globally for potential recovery
      videoUrl = URL.createObjectURL(file);
      video.src = videoUrl;

      // Force load on iOS
      video.load();

      loadOverlay.querySelector('p').textContent = 'Loading video...';

      console.log('Waiting for video metadata...');
      await new Promise((resolve, reject) => {
        video.onloadedmetadata = () => {
          console.info('Video metadata loaded');
          resolve();
        };
        video.onerror = () => {
          console.error('Failed to load video metadata');
          reject(new Error('Video load failed'));
        };
        setTimeout(() => {
          console.error('Metadata load timeout after 10s');
          console.log(`Video readyState: ${video.readyState}`);
        }, 10000);
      });

      state.duration = video.duration;
      state.videoWidth = video.videoWidth;
      state.videoHeight = video.videoHeight;

      console.info(`Video info: ${state.videoWidth}x${state.videoHeight}, duration: ${state.duration.toFixed(2)}s`);
      console.log(`Video readyState: ${video.readyState}`);

      // Set up preview canvas
      previewCanvas.width = state.videoWidth;
      previewCanvas.height = state.videoHeight;
      console.log('Preview canvas configured');

      // Adjust time windows
      adjustWindows();
      console.log(`Time windows: Fine=${stripes[0].window}s, Medium=${stripes[1].window}s, Coarse=${stripes[2].window}s`);

      // Set up stripe canvases
      stripes.forEach((stripe, i) => {
        stripe.canvas.width = stripe.element.clientWidth * 2; // 2x for retina
        stripe.canvas.height = stripe.element.clientHeight * 2;
        stripe.canvas.style.width = stripe.element.clientWidth + 'px';
        stripe.canvas.style.height = stripe.element.clientHeight + 'px';
        stripe.ctx.scale(2, 2);
      });
      console.log('Stripe canvases configured');

      // Extract frames
      console.info('Beginning frame extraction...');
      try {
        await extractFrames();
      } catch (err) {
        console.error(`Frame extraction failed: ${err.message}`);
        return;
      }

      // Load frame images
      console.info(`Loading ${state.frames.length} thumbnail images...`);
      loadOverlay.querySelector('p').textContent = 'Loading thumbnails...';
      let loadedCount = 0;
      await Promise.all(state.frames.map(frame => {
        return new Promise(resolve => {
          const img = new Image();
          img.onload = () => {
            frame.image = img;
            loadedCount++;
            if (loadedCount % 50 === 0) {
              console.log(`Loaded ${loadedCount}/${state.frames.length} thumbnails`);
            }
            resolve();
          };
          img.onerror = () => {
            console.warn(`Failed to load thumbnail for time ${frame.time}`);
            resolve();
          };
          img.src = frame.imageData;
        });
      }));
      console.info('All thumbnails loaded');

      // Initial state
      console.log('Seeking to start...');
      video.currentTime = 0;
      state.currentTime = 0;

      await new Promise(resolve => {
        const onInitialSeek = () => {
          video.removeEventListener('seeked', onInitialSeek);
          resolve();
        };
        video.addEventListener('seeked', onInitialSeek);
      });

      // Clear any lingering onseeked handler from extraction
      video.onseeked = null;

      console.log('Drawing initial state...');
      drawPreview();
      updateTimeDisplay();
      drawAllStripes();

      loadOverlay.classList.add('hidden');
      console.info('Video editor ready!');
      animate();
    }

    // Touch handling for stripes
    // Vertical scroll state for stripes container
    const stripesContainer = document.getElementById('stripes-container');
    let containerScrollY = 0;
    const stripeHeight = 80;
    const visibleStripes = 3;

    function updateContainerScroll() {
      const maxScroll = (stripes.length - visibleStripes) * stripeHeight;
      containerScrollY = Math.max(0, Math.min(maxScroll, containerScrollY));
      stripesContainer.style.transform = `translateY(${-containerScrollY}px)`;
    }

    function setupStripeTouch(stripe) {
      let startX = 0;
      let startY = 0;
      let startTime = 0;
      let startScrollY = 0;
      let isDragging = false;
      let direction = null; // 'horizontal' or 'vertical'

      const handleStart = (e) => {
        e.preventDefault();
        const touch = e.touches ? e.touches[0] : e;
        startX = touch.clientX;
        startY = touch.clientY;
        startTime = state.currentTime;
        startScrollY = containerScrollY;
        isDragging = true;
        direction = null;

        if (state.isPlaying) {
          video.pause();
          state.isPlaying = false;
          playIndicator.classList.remove('playing');
        }
      };

      const handleMove = (e) => {
        if (!isDragging) return;
        e.preventDefault();

        const touch = e.touches ? e.touches[0] : e;
        const deltaX = touch.clientX - startX;
        const deltaY = touch.clientY - startY;

        // Determine direction on first significant movement
        if (!direction) {
          if (Math.abs(deltaX) > 10 || Math.abs(deltaY) > 10) {
            direction = Math.abs(deltaX) > Math.abs(deltaY) ? 'horizontal' : 'vertical';
          } else {
            return;
          }
        }

        if (direction === 'horizontal') {
          // Scrub timeline
          const pixelsPerSecond = stripe.element.clientWidth / stripe.window;
          const timeDelta = -deltaX / pixelsPerSecond;
          seekTo(startTime + timeDelta);
        } else {
          // Scroll stripes vertically
          containerScrollY = startScrollY - deltaY;
          updateContainerScroll();
        }
      };

      const handleEnd = () => {
        isDragging = false;
        direction = null;
      };

      stripe.element.addEventListener('touchstart', handleStart, { passive: false });
      stripe.element.addEventListener('touchmove', handleMove, { passive: false });
      stripe.element.addEventListener('touchend', handleEnd);
      stripe.element.addEventListener('touchcancel', handleEnd);

      // Mouse support for desktop testing
      stripe.element.addEventListener('mousedown', handleStart);
      window.addEventListener('mousemove', handleMove);
      window.addEventListener('mouseup', handleEnd);
    }

    // Preview tap to play/pause
    previewCanvas.addEventListener('click', () => {
      if (state.duration === 0) return;

      if (state.isPlaying) {
        video.pause();
        state.isPlaying = false;
        playIndicator.classList.remove('playing');
      } else {
        video.play();
        state.isPlaying = true;
        playIndicator.classList.add('playing');
      }

      playIndicator.classList.add('show');
      setTimeout(() => playIndicator.classList.remove('show'), 500);
    });

    // Video ended
    video.addEventListener('ended', () => {
      state.isPlaying = false;
      playIndicator.classList.remove('playing');
    });

    // App ready flag
    let appReady = false;

    // File input - with ready check
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        if (!appReady) {
          console.warn('App not ready, waiting...');
          setTimeout(() => {
            if (file) loadVideo(file);
          }, 100);
        } else {
          loadVideo(file);
        }
      }
    });

    // Initialize app when DOM is fully ready
    function initApp() {
      console.info('App initializing...');

      // Small delay to ensure all elements are rendered
      setTimeout(() => {
        appReady = true;
        console.info('App ready!');

        // Auto-show control panel so user can load a video
        controlPanel.classList.add('visible');
      }, 200);
    }

    // Start initialization
    if (document.readyState === 'complete') {
      initApp();
    } else {
      window.addEventListener('load', initApp);
    }

    // Handle resize
    window.addEventListener('resize', () => {
      if (state.duration === 0) return;

      stripes.forEach(stripe => {
        stripe.canvas.width = stripe.element.clientWidth * 2;
        stripe.canvas.height = stripe.element.clientHeight * 2;
        stripe.canvas.style.width = stripe.element.clientWidth + 'px';
        stripe.canvas.style.height = stripe.element.clientHeight + 'px';
        stripe.ctx.setTransform(1, 0, 0, 1, 0, 0);
        stripe.ctx.scale(2, 2);
      });

      drawAllStripes();
    });

    // Initialize touch handling
    stripes.forEach(setupStripeTouch);

    // ===== EDIT FUNCTIONALITY =====
    const btnMarkIn = document.getElementById('btn-mark-in');
    const btnMarkOut = document.getElementById('btn-mark-out');
    const btnKeep = document.getElementById('btn-keep');
    const btnDelete = document.getElementById('btn-delete');
    const btnMove = document.getElementById('btn-move');
    const btnClear = document.getElementById('btn-clear');
    const markerDisplay = document.getElementById('marker-display');
    const editListStripe = document.getElementById('edit-list-stripe');
    const editListCanvas = editListStripe.querySelector('canvas');
    const editListCtx = editListCanvas.getContext('2d');

    // Get current selection (range or single frame)
    function getSelection() {
      let inTime, outTime;
      if (state.markIn !== null && state.markOut !== null) {
        inTime = state.markIn;
        outTime = state.markOut;
      } else if (state.markIn !== null) {
        inTime = state.markIn;
        outTime = state.markIn + state.frameInterval;
      } else if (state.markOut !== null) {
        inTime = state.markOut;
        outTime = state.markOut + state.frameInterval;
      } else {
        inTime = state.currentTime;
        outTime = state.currentTime + state.frameInterval;
      }
      return { inTime, outTime };
    }

    function updateMarkerDisplay() {
      if (state.markIn === null && state.markOut === null) {
        markerDisplay.style.display = 'none';
        btnMarkIn.classList.remove('active');
        btnMarkOut.classList.remove('active');
      } else {
        markerDisplay.style.display = 'block';
        let text = '';
        if (state.markIn !== null) {
          text += `IN: ${formatTime(state.markIn)}`;
          btnMarkIn.classList.add('active');
        } else {
          btnMarkIn.classList.remove('active');
        }
        if (state.markOut !== null) {
          if (text) text += ' | ';
          text += `OUT: ${formatTime(state.markOut)}`;
          btnMarkOut.classList.add('active');
        } else {
          btnMarkOut.classList.remove('active');
        }
        if (state.markIn !== null && state.markOut !== null) {
          const duration = Math.abs(state.markOut - state.markIn);
          text += ` (${duration.toFixed(2)}s)`;
        }
        markerDisplay.textContent = text;
      }
      drawAllStripes();
    }

    // Mark In button
    btnMarkIn.addEventListener('click', () => {
      state.markIn = state.currentTime;
      if (state.markOut !== null && state.markOut < state.markIn) {
        [state.markIn, state.markOut] = [state.markOut, state.markIn];
      }
      console.info(`Mark IN set: ${formatTime(state.markIn)}`);
      updateMarkerDisplay();
    });

    // Mark Out button
    btnMarkOut.addEventListener('click', () => {
      state.markOut = state.currentTime;
      if (state.markIn !== null && state.markIn > state.markOut) {
        [state.markIn, state.markOut] = [state.markOut, state.markIn];
      }
      console.info(`Mark OUT set: ${formatTime(state.markOut)}`);
      updateMarkerDisplay();
    });

    // Clear markers button
    btnClear.addEventListener('click', () => {
      state.markIn = null;
      state.markOut = null;
      console.info('Markers cleared');
      updateMarkerDisplay();
    });

    // KEEP - add to edit list (doesn't remove from source)
    btnKeep.addEventListener('click', () => {
      const { inTime, outTime } = getSelection();
      state.editList.push({ inTime, outTime });
      state.editListDuration = state.editList.reduce((sum, clip) => sum + (clip.outTime - clip.inTime), 0);
      console.info(`KEEP: ${formatTime(inTime)} - ${formatTime(outTime)}`);
      console.info(`Edit list: ${state.editList.length} clips, ${state.editListDuration.toFixed(2)}s`);
      state.markIn = null;
      state.markOut = null;
      updateMarkerDisplay();
      editListStripe.classList.add('has-clips');
      document.getElementById('stripes-area').classList.add('has-edit-list');
      drawEditListStripe();
    });

    // DELETE - remove from source (add to deleted ranges)
    btnDelete.addEventListener('click', () => {
      const { inTime, outTime } = getSelection();
      state.deletedRanges.push({ inTime, outTime });
      console.info(`DELETE: ${formatTime(inTime)} - ${formatTime(outTime)}`);
      state.markIn = null;
      state.markOut = null;
      updateMarkerDisplay();
      drawAllStripes();
    });

    // MOVE - add to edit list AND delete from source
    btnMove.addEventListener('click', () => {
      const { inTime, outTime } = getSelection();
      // Add to edit list
      state.editList.push({ inTime, outTime });
      state.editListDuration = state.editList.reduce((sum, clip) => sum + (clip.outTime - clip.inTime), 0);
      // Add to deleted
      state.deletedRanges.push({ inTime, outTime });
      console.info(`MOVE: ${formatTime(inTime)} - ${formatTime(outTime)}`);
      console.info(`Edit list: ${state.editList.length} clips, ${state.editListDuration.toFixed(2)}s`);
      state.markIn = null;
      state.markOut = null;
      updateMarkerDisplay();
      editListStripe.classList.add('has-clips');
      document.getElementById('stripes-area').classList.add('has-edit-list');
      drawEditListStripe();
      drawAllStripes();
    });

    // Check if a time is in a deleted range
    function isDeleted(time) {
      return state.deletedRanges.some(r => time >= r.inTime && time < r.outTime);
    }

    // Draw edit list stripe as continuous timeline of kept clips
    function drawEditListStripe() {
      if (state.editList.length === 0) return;

      const width = editListStripe.clientWidth;
      const height = editListStripe.clientHeight;

      editListCanvas.width = width * 2;
      editListCanvas.height = height * 2;
      editListCanvas.style.width = width + 'px';
      editListCanvas.style.height = height + 'px';
      editListCtx.setTransform(1, 0, 0, 1, 0, 0);
      editListCtx.scale(2, 2);

      editListCtx.fillStyle = '#1a1a2e';
      editListCtx.fillRect(0, 0, width, height);

      const frameHeight = height - 4;
      const frameWidth = Math.round((state.videoWidth / state.videoHeight) * frameHeight);

      // Calculate how many frames fit on screen
      const maxFrames = Math.floor(width / (frameWidth + 2));

      // Calculate total frames in edit list based on frame interval
      const totalEditFrames = Math.ceil(state.editListDuration / state.frameInterval);

      // If more frames than fit, we need to skip some
      const frameStep = totalEditFrames > maxFrames ? totalEditFrames / maxFrames : 1;

      let x = 0;
      let editTime = 0; // Time position in edit list timeline

      for (let i = 0; i < maxFrames && editTime < state.editListDuration; i++) {
        // Find which clip and source time this edit time corresponds to
        let accumulatedTime = 0;
        let sourceTime = null;

        for (const clip of state.editList) {
          const clipDuration = clip.outTime - clip.inTime;
          if (editTime < accumulatedTime + clipDuration) {
            // This frame is in this clip
            const offsetInClip = editTime - accumulatedTime;
            sourceTime = clip.inTime + offsetInClip;
            break;
          }
          accumulatedTime += clipDuration;
        }

        if (sourceTime !== null) {
          const frame = getFrameAtTime(sourceTime);
          if (frame && frame.image) {
            editListCtx.drawImage(frame.image, x, 2, frameWidth, frameHeight);
            editListCtx.strokeStyle = '#3b82f6';
            editListCtx.strokeRect(x, 2, frameWidth, frameHeight);
          }
        }

        x += frameWidth + 2;
        editTime += frameStep * state.frameInterval;
      }

      // Update label
      editListStripe.querySelector('.stripe-label').textContent =
        `Edit List (${state.editList.length} clips, ${state.editListDuration.toFixed(1)}s)`;
    }

    // Override drawStripe to show markers and deleted regions
    const originalDrawStripe = drawStripe;
    drawStripe = function(stripe) {
      originalDrawStripe(stripe);

      const ctx = stripe.ctx;
      const width = stripe.element.clientWidth;
      const height = stripe.element.clientHeight;
      const timeWindow = stripe.window;
      const timePerPixel = timeWindow / width;
      const centerX = width / 2;

      // Draw deleted regions as red overlay
      state.deletedRanges.forEach(range => {
        const inDiff = range.inTime - state.currentTime;
        const outDiff = range.outTime - state.currentTime;
        const x1 = centerX + (inDiff / timePerPixel);
        const x2 = centerX + (outDiff / timePerPixel);
        if (x2 > 0 && x1 < width) {
          ctx.fillStyle = 'rgba(239, 68, 68, 0.4)';
          ctx.fillRect(Math.max(0, x1), 0, Math.min(width, x2) - Math.max(0, x1), height);
          // Strikethrough pattern
          ctx.strokeStyle = 'rgba(239, 68, 68, 0.6)';
          ctx.lineWidth = 1;
          for (let lx = Math.max(0, x1); lx < Math.min(width, x2); lx += 10) {
            ctx.beginPath();
            ctx.moveTo(lx, 0);
            ctx.lineTo(lx + height, height);
            ctx.stroke();
          }
        }
      });

      // Draw mark in
      if (state.markIn !== null) {
        const timeDiff = state.markIn - state.currentTime;
        const x = centerX + (timeDiff / timePerPixel);
        if (x >= 0 && x <= width) {
          ctx.strokeStyle = '#22c55e';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(x + 10, 0);
          ctx.lineTo(x, 0);
          ctx.lineTo(x, height);
          ctx.lineTo(x + 10, height);
          ctx.stroke();
        }
      }

      // Draw mark out
      if (state.markOut !== null) {
        const timeDiff = state.markOut - state.currentTime;
        const x = centerX + (timeDiff / timePerPixel);
        if (x >= 0 && x <= width) {
          ctx.strokeStyle = '#ef4444';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(x - 10, 0);
          ctx.lineTo(x, 0);
          ctx.lineTo(x, height);
          ctx.lineTo(x - 10, height);
          ctx.stroke();
        }
      }

      // Highlight region between markers
      if (state.markIn !== null && state.markOut !== null) {
        const inDiff = state.markIn - state.currentTime;
        const outDiff = state.markOut - state.currentTime;
        const x1 = centerX + (inDiff / timePerPixel);
        const x2 = centerX + (outDiff / timePerPixel);
        ctx.fillStyle = 'rgba(59, 130, 246, 0.3)';
        ctx.fillRect(Math.max(0, x1), 0, Math.min(width, x2) - Math.max(0, x1), height);
      }
    };
  </script>
</body>
</html>
