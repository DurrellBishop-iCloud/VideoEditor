<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Three Line Edit</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: none;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #1a1a1a;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
    }

    #app {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
    }

    /* File input overlay */
    #load-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #1a1a1a;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      color: #fff;
    }

    #load-overlay.hidden {
      display: none;
    }

    #load-overlay label {
      padding: 20px 40px;
      background: #3b82f6;
      border-radius: 12px;
      font-size: 18px;
      font-weight: 600;
      cursor: pointer;
    }

    #load-overlay input {
      display: none;
    }

    #load-overlay p {
      margin-top: 20px;
      color: #888;
      font-size: 14px;
    }

    /* Preview area - top half */
    #preview-area {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #000;
      position: relative;
      overflow: hidden;
    }

    #video {
      display: none;
    }

    #preview-canvas {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    #play-indicator {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 60px;
      height: 60px;
      background: rgba(0,0,0,0.6);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
    }

    #play-indicator.show {
      opacity: 1;
    }

    #play-indicator::after {
      content: '';
      width: 0;
      height: 0;
      border-left: 20px solid white;
      border-top: 12px solid transparent;
      border-bottom: 12px solid transparent;
      margin-left: 5px;
    }

    #play-indicator.playing::after {
      border: none;
      width: 20px;
      height: 24px;
      background: linear-gradient(to right, white 35%, transparent 35%, transparent 65%, white 65%);
      margin-left: 0;
    }

    #time-display {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 6px 14px;
      border-radius: 6px;
      font-size: 14px;
      font-variant-numeric: tabular-nums;
    }

    /* Stripes area - bottom half */
    #stripes-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #0a0a0a;
      position: relative;
    }

    /* Center line indicator */
    #center-line {
      position: absolute;
      top: 0;
      left: 50%;
      width: 2px;
      height: 100%;
      background: #ef4444;
      z-index: 10;
      pointer-events: none;
    }

    #center-line::before,
    #center-line::after {
      content: '';
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
    }

    #center-line::before {
      top: 0;
      border-top: 10px solid #ef4444;
    }

    #center-line::after {
      bottom: 0;
      border-bottom: 10px solid #ef4444;
    }

    .stripe {
      flex: 1;
      position: relative;
      overflow: hidden;
      border-bottom: 1px solid #333;
    }

    .stripe:last-child {
      border-bottom: none;
    }

    .stripe-label {
      position: absolute;
      top: 4px;
      left: 8px;
      background: rgba(0,0,0,0.7);
      color: #888;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
      z-index: 5;
      pointer-events: none;
    }

    .stripe canvas {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
    }

    /* Version number */
    #version {
      position: fixed;
      top: 10px;
      left: 10px;
      color: #666;
      font-size: 11px;
      z-index: 1001;
      pointer-events: none;
    }

    /* Debug Toggle Button */
    #debug-toggle {
      position: fixed;
      top: 10px;
      right: 10px;
      width: 36px;
      height: 36px;
      background: rgba(0, 0, 0, 0.6);
      border: none;
      border-radius: 50%;
      z-index: 1001;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
    }

    /* Debug Console */
    #debug-console {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 40%;
      background: rgba(0, 0, 0, 0.95);
      border-top: 2px solid #22c55e;
      z-index: 1000;
      display: none;
      flex-direction: column;
      font-family: 'SF Mono', Monaco, 'Courier New', monospace;
    }

    #debug-console.visible {
      display: flex;
    }

    #debug-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: #1a1a1a;
      border-bottom: 1px solid #333;
    }

    #debug-header span {
      color: #22c55e;
      font-size: 12px;
      font-weight: bold;
    }

    #debug-buttons {
      display: flex;
      gap: 8px;
    }

    #debug-buttons button {
      padding: 6px 12px;
      font-size: 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 600;
    }

    #copy-btn {
      background: #3b82f6;
      color: white;
    }

    #clear-btn {
      background: #ef4444;
      color: white;
    }

    #debug-log {
      flex: 1;
      overflow-y: auto;
      padding: 8px 12px;
      font-size: 11px;
      line-height: 1.4;
      -webkit-overflow-scrolling: touch;
      user-select: text;
      -webkit-user-select: text;
    }

    .log-entry {
      padding: 4px 0;
      border-bottom: 1px solid #222;
      color: #ddd;
      word-wrap: break-word;
    }

    .log-entry.error {
      color: #ef4444;
    }

    .log-entry.warn {
      color: #f59e0b;
    }

    .log-entry.info {
      color: #22c55e;
    }

    .log-time {
      color: #666;
      margin-right: 8px;
    }

    #copy-toast {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #22c55e;
      color: white;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 1001;
    }

    #copy-toast.show {
      opacity: 1;
    }
  </style>
</head>
<body>
  <!-- Version -->
  <div id="version">v1.0</div>

  <!-- Debug Toggle -->
  <button id="debug-toggle">&#9881;</button>

  <!-- Debug Console -->
  <div id="debug-console">
    <div id="debug-header">
      <span>DEBUG CONSOLE</span>
      <div id="debug-buttons">
        <button id="copy-btn">Copy All</button>
        <button id="clear-btn">Clear</button>
      </div>
    </div>
    <div id="debug-log"></div>
  </div>
  <div id="copy-toast">Copied to clipboard!</div>

  <div id="app">
    <div id="load-overlay">
      <label>
        Load Video
        <input type="file" id="file-input" accept="video/*">
      </label>
      <p>Select a video file to begin editing</p>
    </div>

    <div id="preview-area">
      <video id="video" playsinline></video>
      <canvas id="preview-canvas"></canvas>
      <div id="play-indicator"></div>
      <div id="time-display">00:00.000 / 00:00.000</div>
    </div>

    <div id="stripes-area">
      <div id="center-line"></div>
      <div class="stripe" id="stripe-fine">
        <span class="stripe-label">Fine</span>
        <canvas></canvas>
      </div>
      <div class="stripe" id="stripe-medium">
        <span class="stripe-label">Medium</span>
        <canvas></canvas>
      </div>
      <div class="stripe" id="stripe-coarse">
        <span class="stripe-label">Coarse</span>
        <canvas></canvas>
      </div>
    </div>
  </div>

  <script>
    // ===== DEBUG CONSOLE =====
    const debugConsole = document.getElementById('debug-console');
    const debugToggle = document.getElementById('debug-toggle');
    const debugLog = document.getElementById('debug-log');
    const copyBtn = document.getElementById('copy-btn');
    const clearBtn = document.getElementById('clear-btn');
    const copyToast = document.getElementById('copy-toast');
    let logEntries = [];

    // Toggle debug console
    debugToggle.addEventListener('click', () => {
      debugConsole.classList.toggle('visible');
    });

    function getTimestamp() {
      const now = new Date();
      return now.toTimeString().split(' ')[0] + '.' + now.getMilliseconds().toString().padStart(3, '0');
    }

    function addLog(message, type = 'log') {
      const timestamp = getTimestamp();
      const entry = { timestamp, message: String(message), type };
      logEntries.push(entry);

      const div = document.createElement('div');
      div.className = `log-entry ${type}`;
      div.innerHTML = `<span class="log-time">${timestamp}</span>${String(message).replace(/</g, '&lt;').replace(/>/g, '&gt;')}`;
      debugLog.appendChild(div);
      debugLog.scrollTop = debugLog.scrollHeight;
    }

    // Capture console methods
    const originalLog = console.log;
    const originalError = console.error;
    const originalWarn = console.warn;
    const originalInfo = console.info;

    console.log = function(...args) {
      addLog(args.map(a => typeof a === 'object' ? JSON.stringify(a) : a).join(' '), 'log');
      originalLog.apply(console, args);
    };

    console.error = function(...args) {
      addLog(args.map(a => typeof a === 'object' ? JSON.stringify(a) : a).join(' '), 'error');
      originalError.apply(console, args);
    };

    console.warn = function(...args) {
      addLog(args.map(a => typeof a === 'object' ? JSON.stringify(a) : a).join(' '), 'warn');
      originalWarn.apply(console, args);
    };

    console.info = function(...args) {
      addLog(args.map(a => typeof a === 'object' ? JSON.stringify(a) : a).join(' '), 'info');
      originalInfo.apply(console, args);
    };

    // Capture errors
    window.onerror = function(msg, url, lineNo, columnNo, error) {
      addLog(`ERROR: ${msg} at ${url}:${lineNo}:${columnNo}`, 'error');
      return false;
    };

    window.onunhandledrejection = function(event) {
      addLog(`UNHANDLED PROMISE: ${event.reason}`, 'error');
    };

    // Copy button
    copyBtn.addEventListener('click', async () => {
      const text = logEntries.map(e => `[${e.timestamp}] [${e.type.toUpperCase()}] ${e.message}`).join('\n');
      try {
        await navigator.clipboard.writeText(text);
        copyToast.classList.add('show');
        setTimeout(() => copyToast.classList.remove('show'), 1500);
      } catch (err) {
        // Fallback for iOS
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed';
        textarea.style.top = '50%';
        textarea.style.left = '0';
        textarea.style.width = '100%';
        textarea.style.height = '200px';
        textarea.style.zIndex = '9999';
        textarea.style.fontSize = '12px';
        document.body.appendChild(textarea);
        textarea.focus();
        textarea.select();
        addLog('Text area opened - select all and copy manually', 'info');
      }
    });

    // Clear button
    clearBtn.addEventListener('click', () => {
      debugLog.innerHTML = '';
      logEntries = [];
      addLog('Console cleared', 'info');
    });

    console.info('Debug console initialized');
    console.info('User Agent: ' + navigator.userAgent);

    // ===== MAIN APP =====

    // State
    const state = {
      video: null,
      duration: 0,
      currentTime: 0,
      isPlaying: false,
      frames: [], // Cached frame images
      frameInterval: 1/30, // Seconds between cached frames
      videoWidth: 0,
      videoHeight: 0
    };

    // Elements
    const video = document.getElementById('video');
    const previewCanvas = document.getElementById('preview-canvas');
    const previewCtx = previewCanvas.getContext('2d');
    const playIndicator = document.getElementById('play-indicator');
    const timeDisplay = document.getElementById('time-display');
    const loadOverlay = document.getElementById('load-overlay');
    const fileInput = document.getElementById('file-input');
    const stripesArea = document.getElementById('stripes-area');

    // Stripe configurations (will be set relative to video length)
    const stripes = [
      { id: 'stripe-fine', baseWindow: 0.5, label: 'Fine' },
      { id: 'stripe-medium', baseWindow: 5, label: 'Medium' },
      { id: 'stripe-coarse', baseWindow: 10, label: 'Coarse' }
    ];

    // Initialize stripe data
    stripes.forEach(stripe => {
      stripe.element = document.getElementById(stripe.id);
      stripe.canvas = stripe.element.querySelector('canvas');
      stripe.ctx = stripe.canvas.getContext('2d');
      stripe.window = stripe.baseWindow; // Will be adjusted
    });

    // Format time as MM:SS.mmm
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      const ms = Math.floor((seconds % 1) * 1000);
      return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
    }

    // Update time display
    function updateTimeDisplay() {
      timeDisplay.textContent = `${formatTime(state.currentTime)} / ${formatTime(state.duration)}`;
    }

    // Adjust windows relative to video length
    function adjustWindows() {
      const dur = state.duration;
      // Scale windows: for a 60s video, use base values
      // For shorter/longer, scale proportionally but with limits
      const scale = Math.max(0.1, Math.min(2, dur / 60));

      stripes[0].window = Math.max(0.25, 0.5 * scale);   // Fine: 0.25s - 1s
      stripes[1].window = Math.max(2, 5 * scale);        // Medium: 2s - 10s
      stripes[2].window = Math.max(5, 10 * scale);       // Coarse: 5s - 20s

      // Update labels
      stripes[0].element.querySelector('.stripe-label').textContent =
        `Fine (${stripes[0].window.toFixed(1)}s)`;
      stripes[1].element.querySelector('.stripe-label').textContent =
        `Medium (${stripes[1].window.toFixed(1)}s)`;
      stripes[2].element.querySelector('.stripe-label').textContent =
        `Coarse (${stripes[2].window.toFixed(1)}s)`;
    }

    // Extract frames from video
    async function extractFrames() {
      console.info('Starting frame extraction...');
      state.frames = [];
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');

      // Use smaller thumbnails for memory efficiency
      const thumbHeight = 80;
      const thumbWidth = Math.round((state.videoWidth / state.videoHeight) * thumbHeight);
      tempCanvas.width = thumbWidth;
      tempCanvas.height = thumbHeight;

      console.log(`Thumb size: ${thumbWidth}x${thumbHeight}`);

      const totalFrames = Math.ceil(state.duration / state.frameInterval);
      console.log(`Total frames to extract: ${totalFrames} (duration: ${state.duration}s, interval: ${state.frameInterval}s)`);

      return new Promise((resolve, reject) => {
        let frameIndex = 0;
        let seekTimeout = null;
        let lastSeekTime = Date.now();

        const extractNext = () => {
          if (frameIndex >= totalFrames) {
            console.info(`Frame extraction complete! ${state.frames.length} frames extracted`);
            resolve();
            return;
          }

          const time = frameIndex * state.frameInterval;
          console.log(`Seeking to frame ${frameIndex}/${totalFrames} at time ${time.toFixed(3)}s`);
          lastSeekTime = Date.now();

          // Set a timeout to detect if seeking hangs
          if (seekTimeout) clearTimeout(seekTimeout);
          seekTimeout = setTimeout(() => {
            console.error(`SEEK TIMEOUT! Stuck at frame ${frameIndex}, time ${time.toFixed(3)}s`);
            console.error(`Video readyState: ${video.readyState}, networkState: ${video.networkState}`);
            console.error(`Video seeking: ${video.seeking}, paused: ${video.paused}`);
            // Try to continue anyway
            frameIndex++;
            extractNext();
          }, 5000);

          video.currentTime = time;
        };

        video.onseeked = () => {
          if (seekTimeout) clearTimeout(seekTimeout);
          const seekDuration = Date.now() - lastSeekTime;

          try {
            tempCtx.drawImage(video, 0, 0, thumbWidth, thumbHeight);
            state.frames.push({
              time: frameIndex * state.frameInterval,
              imageData: tempCanvas.toDataURL('image/jpeg', 0.7)
            });
            frameIndex++;

            // Show progress
            const progress = Math.round((frameIndex / totalFrames) * 100);
            loadOverlay.querySelector('p').textContent = `Extracting frames: ${progress}%`;

            // Log every 10 frames to avoid spam
            if (frameIndex % 10 === 0 || frameIndex === 1) {
              console.log(`Extracted frame ${frameIndex}/${totalFrames} (${progress}%) - seek took ${seekDuration}ms`);
            }

            // Use setTimeout to prevent blocking
            setTimeout(extractNext, 0);
          } catch (err) {
            console.error(`Error extracting frame ${frameIndex}: ${err.message}`);
            frameIndex++;
            setTimeout(extractNext, 0);
          }
        };

        video.onerror = (e) => {
          console.error(`Video error: ${video.error ? video.error.message : 'unknown'}`);
          console.error(`Error code: ${video.error ? video.error.code : 'N/A'}`);
        };

        console.log('Starting extraction loop...');
        extractNext();
      });
    }

    // Draw preview frame
    function drawPreview() {
      previewCtx.drawImage(video, 0, 0, previewCanvas.width, previewCanvas.height);
    }

    // Find closest cached frame
    function getFrameAtTime(time) {
      if (state.frames.length === 0) return null;

      let closest = state.frames[0];
      let minDiff = Math.abs(time - closest.time);

      for (const frame of state.frames) {
        const diff = Math.abs(time - frame.time);
        if (diff < minDiff) {
          minDiff = diff;
          closest = frame;
        }
        if (frame.time > time) break; // Frames are sorted
      }

      return closest;
    }

    // Draw a stripe
    function drawStripe(stripe) {
      const ctx = stripe.ctx;
      const timeWindow = stripe.window;

      // Use element dimensions (not canvas dimensions which are 2x for retina)
      const width = stripe.element.clientWidth;
      const height = stripe.element.clientHeight;

      ctx.fillStyle = '#0a0a0a';
      ctx.fillRect(0, 0, width, height);

      // Calculate frame dimensions
      const frameHeight = height - 4;
      const frameWidth = Math.round((state.videoWidth / state.videoHeight) * frameHeight);

      // Time per pixel
      const timePerPixel = timeWindow / width;

      // Center of the stripe = current time
      const centerX = width / 2;

      // How many frames to show (enough to fill the width plus extra)
      const framesNeeded = Math.ceil(width / frameWidth) + 4;

      // Draw frames centered on current time
      for (let i = -Math.ceil(framesNeeded / 2); i <= Math.ceil(framesNeeded / 2); i++) {
        // Calculate time offset for this frame position
        const pixelOffset = i * frameWidth;
        const frameTime = state.currentTime + (pixelOffset * timePerPixel);

        if (frameTime < 0 || frameTime > state.duration) continue;

        const frame = getFrameAtTime(frameTime);
        if (!frame || !frame.image) continue;

        // Position: center of frame aligns with its time position
        const timeDiff = frameTime - state.currentTime;
        const x = centerX + (timeDiff / timePerPixel) - (frameWidth / 2);

        ctx.drawImage(frame.image, x, 2, frameWidth, frameHeight);

        // Draw subtle border
        ctx.strokeStyle = '#333';
        ctx.strokeRect(x, 2, frameWidth, frameHeight);
      }
    }

    // Draw all stripes
    function drawAllStripes() {
      stripes.forEach(drawStripe);
    }

    // Seek video to time
    function seekTo(time) {
      state.currentTime = Math.max(0, Math.min(state.duration, time));
      video.currentTime = state.currentTime;
      updateTimeDisplay();
      drawAllStripes();
    }

    // Update preview when video seeks (for scrubbing)
    video.addEventListener('seeked', () => {
      if (!state.isPlaying) {
        drawPreview();
      }
    });

    // Animation loop
    function animate() {
      if (state.isPlaying) {
        state.currentTime = video.currentTime;
        drawPreview();
        updateTimeDisplay();
        drawAllStripes();
      }
      requestAnimationFrame(animate);
    }

    // Handle video load
    async function loadVideo(file) {
      console.info(`Loading video: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`);
      console.log(`File type: ${file.type}`);

      const url = URL.createObjectURL(file);
      video.src = url;

      loadOverlay.querySelector('p').textContent = 'Loading video...';

      console.log('Waiting for video metadata...');
      await new Promise((resolve, reject) => {
        video.onloadedmetadata = () => {
          console.info('Video metadata loaded');
          resolve();
        };
        video.onerror = () => {
          console.error('Failed to load video metadata');
          reject(new Error('Video load failed'));
        };
        setTimeout(() => {
          console.error('Metadata load timeout after 10s');
          console.log(`Video readyState: ${video.readyState}`);
        }, 10000);
      });

      state.duration = video.duration;
      state.videoWidth = video.videoWidth;
      state.videoHeight = video.videoHeight;

      console.info(`Video info: ${state.videoWidth}x${state.videoHeight}, duration: ${state.duration.toFixed(2)}s`);
      console.log(`Video readyState: ${video.readyState}`);

      // Set up preview canvas
      previewCanvas.width = state.videoWidth;
      previewCanvas.height = state.videoHeight;
      console.log('Preview canvas configured');

      // Adjust time windows
      adjustWindows();
      console.log(`Time windows: Fine=${stripes[0].window}s, Medium=${stripes[1].window}s, Coarse=${stripes[2].window}s`);

      // Set up stripe canvases
      stripes.forEach((stripe, i) => {
        stripe.canvas.width = stripe.element.clientWidth * 2; // 2x for retina
        stripe.canvas.height = stripe.element.clientHeight * 2;
        stripe.canvas.style.width = stripe.element.clientWidth + 'px';
        stripe.canvas.style.height = stripe.element.clientHeight + 'px';
        stripe.ctx.scale(2, 2);
      });
      console.log('Stripe canvases configured');

      // Extract frames
      console.info('Beginning frame extraction...');
      try {
        await extractFrames();
      } catch (err) {
        console.error(`Frame extraction failed: ${err.message}`);
        return;
      }

      // Load frame images
      console.info(`Loading ${state.frames.length} thumbnail images...`);
      loadOverlay.querySelector('p').textContent = 'Loading thumbnails...';
      let loadedCount = 0;
      await Promise.all(state.frames.map(frame => {
        return new Promise(resolve => {
          const img = new Image();
          img.onload = () => {
            frame.image = img;
            loadedCount++;
            if (loadedCount % 50 === 0) {
              console.log(`Loaded ${loadedCount}/${state.frames.length} thumbnails`);
            }
            resolve();
          };
          img.onerror = () => {
            console.warn(`Failed to load thumbnail for time ${frame.time}`);
            resolve();
          };
          img.src = frame.imageData;
        });
      }));
      console.info('All thumbnails loaded');

      // Initial state
      console.log('Seeking to start...');
      video.currentTime = 0;
      state.currentTime = 0;

      await new Promise(resolve => {
        video.onseeked = resolve;
      });

      console.log('Drawing initial state...');
      drawPreview();
      updateTimeDisplay();
      drawAllStripes();

      loadOverlay.classList.add('hidden');
      console.info('Video editor ready!');
      animate();
    }

    // Touch handling for stripes
    function setupStripeTouch(stripe) {
      let startX = 0;
      let startTime = 0;
      let isDragging = false;

      const handleStart = (e) => {
        e.preventDefault();
        const touch = e.touches ? e.touches[0] : e;
        startX = touch.clientX;
        startTime = state.currentTime;
        isDragging = true;

        if (state.isPlaying) {
          video.pause();
          state.isPlaying = false;
          playIndicator.classList.remove('playing');
        }
      };

      const handleMove = (e) => {
        if (!isDragging) return;
        e.preventDefault();

        const touch = e.touches ? e.touches[0] : e;
        const deltaX = touch.clientX - startX;

        // Convert pixel delta to time delta based on stripe's window
        const pixelsPerSecond = stripe.element.clientWidth / stripe.window;
        const timeDelta = -deltaX / pixelsPerSecond;

        seekTo(startTime + timeDelta);
      };

      const handleEnd = () => {
        isDragging = false;
      };

      stripe.element.addEventListener('touchstart', handleStart, { passive: false });
      stripe.element.addEventListener('touchmove', handleMove, { passive: false });
      stripe.element.addEventListener('touchend', handleEnd);
      stripe.element.addEventListener('touchcancel', handleEnd);

      // Mouse support for desktop testing
      stripe.element.addEventListener('mousedown', handleStart);
      window.addEventListener('mousemove', handleMove);
      window.addEventListener('mouseup', handleEnd);
    }

    // Preview tap to play/pause
    previewCanvas.addEventListener('click', () => {
      if (state.duration === 0) return;

      if (state.isPlaying) {
        video.pause();
        state.isPlaying = false;
        playIndicator.classList.remove('playing');
      } else {
        video.play();
        state.isPlaying = true;
        playIndicator.classList.add('playing');
      }

      playIndicator.classList.add('show');
      setTimeout(() => playIndicator.classList.remove('show'), 500);
    });

    // Video ended
    video.addEventListener('ended', () => {
      state.isPlaying = false;
      playIndicator.classList.remove('playing');
    });

    // File input
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        loadVideo(file);
      }
    });

    // Handle resize
    window.addEventListener('resize', () => {
      if (state.duration === 0) return;

      stripes.forEach(stripe => {
        stripe.canvas.width = stripe.element.clientWidth * 2;
        stripe.canvas.height = stripe.element.clientHeight * 2;
        stripe.canvas.style.width = stripe.element.clientWidth + 'px';
        stripe.canvas.style.height = stripe.element.clientHeight + 'px';
        stripe.ctx.setTransform(1, 0, 0, 1, 0, 0);
        stripe.ctx.scale(2, 2);
      });

      drawAllStripes();
    });

    // Initialize touch handling
    stripes.forEach(setupStripeTouch);
  </script>
</body>
</html>
